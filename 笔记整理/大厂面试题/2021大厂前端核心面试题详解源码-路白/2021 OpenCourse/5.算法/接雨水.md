# 接雨水

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

示例 1：
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 

示例 2：
输入：height = [4,2,0,3,2,5]
输出：9


## 思路

所以对于这种问题，我们不要想整体，而应该去想局部。

可以发现这道题的思路其实很简单。具体来说，仅仅对于位置 i，能装下多少水呢？ 看图 1.1.jpg

答案是：能装 2 格水，因为 height[i] 的高度为 0，而这里最多能盛 2 格水，2-0=2。

为什么位置 i 最多能盛 2 格水呢？

因为，位置 i 能达到的水柱高度和其左边的最高柱子、右边的最高柱子有关，我们分别称这两个柱子高度为 l_max 和 r_max；
位置 i 最大的水柱高度就是 min(l_max, r_max)。

更进一步，用伪代码来表示位置i能装多少水？

```
water[i] = min(
    // 左边最高的柱子
    max(height[0..i]),  
    // 右边最高的柱子
    max(height[i..end]) 
) - height[i]
```

看图1.2.jpg 1.3.jpg
## 暴力解法

时间复杂度 O(N^2)，空间复杂度 O(1)
## 备忘录解法

之前的暴力解法，在每个位置 i 都要计算 r_max 和 l_max。
这次我们直接把结果都提前计算出来，不用每次都遍历，这时间复杂度就降下来了。

我们开两个数组 r_max 和 l_max 充当备忘录，
l_max[i] 表示位置 i 左边最高的柱子高度，
r_max[i] 表示位置 i 右边最高的柱子高度。
预先把这两个数组计算好，避免重复计算。



// 这个优化其实和暴力解法思路差不多， 就是避免了重复计算， 把时间复杂度降低为 O(N)， 已经是最优了.

// 但是空间复杂度是 O(N)。 下面来看一个精妙一些的解法， 能够把空间复杂度降低到 O(1)。

## 双指针解法

这种解法的思路是完全相同的，但在实现手法上非常巧妙，我们这次也不要用备忘录提前计算了，而是用双指针边走边算，节省下空间复杂度。

先来看看这部分代码是什么意思

```js
function trap(height = []) {
    const n = height.length;
    let left = 0;
    let right = n - 1;

    let l_max = height[0];
    let r_max = height[n - 1];

    while (left <= right) {
        l_max = Math.max(l_max, height[left]);
        r_max = Math.max(r_max, height[right]);
        left++; 
        right--;
    }
}
```

对于这部分代码，请问 l_max 和 r_max 分别表示什么意义呢？

很容易理解，l_max 是 height[0..left] 中最高柱子的高度，r_max 是 height[right..end] 的最高柱子的高度。

然后咱们来看一下解法 ！！！！！看代码

## 双指针答疑

之前的备忘录解法，l_max[i] 和 r_max[i] 分别代表 height[0..i] 和 height[i..end] 的最高柱子高度。
但是双指针解法中，l_max 和 r_max 代表的是 height[0..left] 和 height[right..end] 的最高柱子高度 看图 3.1



有的同学可能对这段代码有所疑问？
此时的 l_max 是 left 指针左边的最高柱子，但是 r_max 并不一定是 left 指针右边最高的柱子，这真的可以得到正确答案吗？
```
if (l_max < r_max) {
    res += l_max - height[left];
    left++; 
}
```

看图3.2

其实这个问题要这么思考，我们只在乎 min(l_max, r_max)。对于上图的情况，
我们已经知道 l_max < r_max 了，至于这个 r_max 是不是右边最大的，不重要。
重要的是 height[i] 能够装的水只和较低的 l_max 之差有关：

看图3.3